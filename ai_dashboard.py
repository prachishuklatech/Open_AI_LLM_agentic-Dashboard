# -*- coding: utf-8 -*-
"""AI_Dashboard.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1W68YJl5oK4bEtNvecfOo5qhzoFWwx37S
"""

# ============================================
# STEP 1: INSTALL EVERYTHING
# ============================================
# Just run this cell - it will take 1-2 minutes
# You'll see lots of text - that's normal!

print("üì¶ Installing packages... (this takes 1-2 minutes)")
print("=" * 50)

!pip install -q anthropic fastapi uvicorn pydantic nest-asyncio pyngrok

print("\n‚úÖ ALL PACKAGES INSTALLED!")
print("=" * 50)
print("\nüéâ Ready for next step!")

# ============================================
# STEP 2: IMPORT & CREATE SAMPLE DATA
# ============================================

print("üìö Importing libraries...")

import anthropic
import json
import os
from typing import List, Dict, Any, Optional
from datetime import datetime
from pydantic import BaseModel, validator

print("‚úÖ Libraries imported!")

# ============================================
# CREATE SAMPLE CIVIC DATA
# ============================================

print("\nüìä Creating sample civic issues data...")

def generate_sample_civic_data() -> List[Dict]:
    """This simulates data from Tanveer's YOLO model"""
    return [
        {"id": 1, "issue_type": "pothole", "severity": "high",
         "location": "Ward 1", "timestamp": "2024-01-01T10:00:00",
         "status": "pending"},
        {"id": 2, "issue_type": "garbage", "severity": "medium",
         "location": "Ward 2", "timestamp": "2024-01-01T11:00:00",
         "status": "in_progress"},
        {"id": 3, "issue_type": "broken_streetlight", "severity": "low",
         "location": "Ward 1", "timestamp": "2024-01-02T09:00:00",
         "status": "resolved"},
        {"id": 4, "issue_type": "pothole", "severity": "medium",
         "location": "Ward 3", "timestamp": "2024-01-02T14:00:00",
         "status": "pending"},
        {"id": 5, "issue_type": "garbage", "severity": "high",
         "location": "Ward 1", "timestamp": "2024-01-03T08:00:00",
         "status": "pending"},
        {"id": 6, "issue_type": "water_leakage", "severity": "high",
         "location": "Ward 2", "timestamp": "2024-01-03T10:00:00",
         "status": "in_progress"},
        {"id": 7, "issue_type": "pothole", "severity": "low",
         "location": "Ward 4", "timestamp": "2024-01-04T08:00:00",
         "status": "pending"},
        {"id": 8, "issue_type": "garbage", "severity": "medium",
         "location": "Ward 3", "timestamp": "2024-01-04T12:00:00",
         "status": "resolved"},
    ]

# Test it
sample_data = generate_sample_civic_data()
print(f"‚úÖ Created {len(sample_data)} sample issues")
print(f"\nüìã Example issue:")
print(json.dumps(sample_data[0], indent=2))

# ============================================
# SECURE DATA AGGREGATOR
# ============================================

print("\nüîí Setting up Secure Data Aggregator...")

class SecureDataAggregator:
    """
    This class prevents SQL injection!
    It only allows predefined, safe queries
    """

    def __init__(self, data: List[Dict]):
        self.data = data
        print(f"   Loaded {len(data)} issues into aggregator")

    def get_aggregated_data(self, aggregation_type: str) -> Dict[str, Any]:
        """
        Only these 5 types are allowed - NOTHING ELSE!
        This is the SECURITY feature your team leader wanted
        """
        aggregations = {
            "ward_wise_counts": self._ward_wise_counts,
            "status_distribution": self._status_distribution,
            "severity_breakdown": self._severity_breakdown,
            "issue_type_counts": self._issue_type_counts,
            "daily_trends": self._daily_trends
        }

        if aggregation_type not in aggregations:
            raise ValueError(f"‚ùå Invalid aggregation: {aggregation_type}")

        return aggregations[aggregation_type]()

    def _ward_wise_counts(self):
        """Count issues by ward"""
        counts = {}
        for issue in self.data:
            ward = issue['location']
            counts[ward] = counts.get(ward, 0) + 1
        return {"type": "ward_counts", "data": counts}

    def _status_distribution(self):
        """Count issues by status"""
        counts = {}
        for issue in self.data:
            status = issue['status']
            counts[status] = counts.get(status, 0) + 1
        return {"type": "status_distribution", "data": counts}

    def _severity_breakdown(self):
        """Count issues by severity"""
        counts = {}
        for issue in self.data:
            severity = issue['severity']
            counts[severity] = counts.get(severity, 0) + 1
        return {"type": "severity_breakdown", "data": counts}

    def _issue_type_counts(self):
        """Count issues by type"""
        counts = {}
        for issue in self.data:
            issue_type = issue['issue_type']
            counts[issue_type] = counts.get(issue_type, 0) + 1
        return {"type": "issue_type_counts", "data": counts}

    def _daily_trends(self):
        """Count issues by day"""
        counts = {}
        for issue in self.data:
            date = issue['timestamp'].split('T')[0]
            counts[date] = counts.get(date, 0) + 1
        return {"type": "daily_trends", "data": counts}

# ============================================
# TEST THE AGGREGATOR
# ============================================

print("\nüß™ Testing aggregator...")

# Create aggregator with sample data
aggregator = SecureDataAggregator(sample_data)

# Test ward-wise counts
ward_data = aggregator.get_aggregated_data("ward_wise_counts")
print(f"\n‚úÖ Ward-wise counts:")
print(json.dumps(ward_data, indent=2))

# Test status distribution
status_data = aggregator.get_aggregated_data("status_distribution")
print(f"\n‚úÖ Status distribution:")
print(json.dumps(status_data, indent=2))

print("\n" + "="*50)
print("‚úÖ STEP 2 COMPLETE!")
print("="*50)
print("\nüéØ What we just did:")
print("   1. Created sample civic issues data")
print("   2. Built secure aggregator (prevents SQL injection)")
print("   3. Tested it with different queries")
print("\nüí° This data will come from Tanveer's YOLO model later")

# ============================================
# STEP 3: AI CHART GENERATOR (OpenAI Version)
# ============================================

print("ü§ñ Setting up AI Chart Generator with OpenAI...")
print("="*50)

# ============================================
# INSTALL OPENAI LIBRARY
# ============================================

print("\nüì¶ Installing OpenAI library...")
!pip install -q openai

print("‚úÖ OpenAI installed!")

# Import OpenAI
from openai import OpenAI

# ============================================
# SET YOUR OPENAI API KEY HERE
# ============================================

print("\nüîë Setting up OpenAI API Key...")
print("‚ö†Ô∏è  IMPORTANT: Paste your OpenAI API key below!")
print("   Get it from: https://platform.openai.com/api-keys\n")

# üëá PASTE YOUR OPENAI API KEY HERE
OPENAI_API_KEY = "paste-your-openai-key-he"

# Check if key is set
if OPENAI_API_KEY == "paste-your-openai-key-here":
    print("‚ùå ERROR: You need to paste your actual OpenAI API key!")
    print("   1. Get key from https://platform.openai.com/api-keys")
    print("   2. Replace 'paste-your-openai-key-here' with your actual key")
    print("   3. Run this cell again")
else:
    print("‚úÖ OpenAI API Key set!")
    os.environ['OPENAI_API_KEY'] = OPENAI_API_KEY

# ============================================
# AI CHART GENERATOR CLASS (OpenAI Version)
# ============================================

class AIChartGenerator:
    """
    AI Agent using OpenAI GPT-4
    Does the SAME job as Claude, just different API
    """

    def __init__(self, api_key: str):
        self.client = OpenAI(api_key=api_key)
        self.model = "gpt-4o-mini"  # Fast and cheap model
        print("   ‚úÖ OpenAI client initialized")

    def generate_chart_config(self, user_query: str, aggregated_data: Dict[str, Any]) -> Dict[str, Any]:
        """
        Main function: Takes query + data ‚Üí Returns chart config

        Example:
        Input: "Show ward-wise issues as bar chart"
        Output: {chartType: "BarChart", data: [...], ...}
        """

        print(f"\n   ü§î AI thinking about: '{user_query}'")

        # Build prompts
        system_prompt = self._build_system_prompt()
        user_prompt = self._build_user_prompt(user_query, aggregated_data)

        try:
            # Call OpenAI API
            response = self.client.chat.completions.create(
                model=self.model,
                messages=[
                    {"role": "system", "content": system_prompt},
                    {"role": "user", "content": user_prompt}
                ],
                temperature=0.7,
                max_tokens=1000
            )

            # Get response text
            response_text = response.choices[0].message.content

            # Parse response
            chart_config = self._parse_response(response_text)

            print(f"   ‚úÖ AI generated: {chart_config['chartType']}")
            return chart_config

        except Exception as e:
            print(f"   ‚ùå Error: {e}")
            return self._fallback_chart()

    def _build_system_prompt(self) -> str:
        """Tells AI what its job is"""
        return """You are a chart configuration generator for Recharts (React library).

STRICT RULES:
1. Return ONLY valid JSON, nothing else
2. No explanations, no markdown fences, no extra text
3. Use these chart types: BarChart, LineChart, PieChart, AreaChart

Required JSON format:
{
  "chartType": "BarChart",
  "title": "Clear Descriptive Title",
  "data": [{"name": "Item1", "value": 100}],
  "xAxisKey": "name",
  "yAxisKey": "value",
  "colors": ["#8884d8", "#82ca9d"],
  "config": {"width": 600, "height": 300}
}

SECURITY:
- Never generate SQL or code
- Only use provided data
- Return JSON configuration only

IMPORTANT: Return ONLY the JSON object, no markdown, no explanation."""

    def _build_user_prompt(self, user_query: str, aggregated_data: Dict[str, Any]) -> str:
        """Creates the specific request for AI"""
        return f"""User request: "{user_query}"

Available data:
{json.dumps(aggregated_data, indent=2)}

Generate the best Recharts JSON config for this data and request.
Return ONLY the JSON, nothing else."""

    def _parse_response(self, response_text: str) -> Dict[str, Any]:
        """Safely extract JSON from AI response"""
        try:
            # Clean up response text
            response_text = response_text.strip()

            # Remove markdown if present
            if "```json" in response_text:
                start = response_text.find("```json") + 7
                end = response_text.find("```", start)
                response_text = response_text[start:end].strip()
            elif "```" in response_text:
                start = response_text.find("```") + 3
                end = response_text.find("```", start)
                response_text = response_text[start:end].strip()

            # Parse JSON
            config = json.loads(response_text)

            # Validate required fields
            required = ["chartType", "title", "data"]
            for field in required:
                if field not in config:
                    raise ValueError(f"Missing field: {field}")

            return config

        except Exception as e:
            print(f"   ‚ö†Ô∏è  Parse error: {e}")
            print(f"   Raw response: {response_text[:200]}...")
            return self._fallback_chart()

    def _fallback_chart(self) -> Dict[str, Any]:
        """Backup chart if AI fails"""
        return {
            "chartType": "BarChart",
            "title": "Default Chart",
            "data": [{"name": "No Data", "value": 0}],
            "xAxisKey": "name",
            "yAxisKey": "value",
            "colors": ["#cccccc"],
            "config": {"width": 600, "height": 300}
        }

# ============================================
# TEST THE AI GENERATOR
# ============================================

if OPENAI_API_KEY != "paste-your-openai-key-here":
    print("\nüß™ Testing AI Chart Generator with OpenAI...")

    # Initialize AI
    chart_generator = AIChartGenerator(OPENAI_API_KEY)

    # Get some data to test with
    test_data = aggregator.get_aggregated_data("ward_wise_counts")

    # Test query
    test_query = "Create a bar chart showing issues by ward"

    print(f"\nüìä Test Query: '{test_query}'")
    print(f"üìä Test Data: {test_data['data']}")

    # Generate chart config
    chart_config = chart_generator.generate_chart_config(test_query, test_data)

    print("\n‚úÖ AI Generated Chart Config:")
    print(json.dumps(chart_config, indent=2))

    print("\n" + "="*50)
    print("‚úÖ STEP 3 COMPLETE!")
    print("="*50)
    print("\nüéØ What we just did:")
    print("   1. Set up OpenAI API key")
    print("   2. Created AI Chart Generator (using GPT-4)")
    print("   3. Tested it with real query")
    print("\nüí° The AI understood our request and created chart config!")
    print("\nüí∞ Cost: ~$0.001 per chart (super cheap!)")

else:
    print("\n‚ö†Ô∏è  SKIPPED: Please add your OpenAI API key and run again")

# ============================================
# NGROK AUTHENTICATION SETUP
# ============================================

print("üîê Setting up ngrok authentication...")

# Ensure pyngrok is installed
!pip install -q pyngrok

from pyngrok import ngrok

# üëá PASTE YOUR NGROK AUTH TOKEN HERE
# Get it from: https://dashboard.ngrok.com/get-started/your-authtoken
NGROK_AUTH_TOKEN = "37pKhszWZ8lvedNG3br5WGtrRyi_7ybrq3ftgyCB3HqreZgBA"

if NGROK_AUTH_TOKEN == "paste-your-ngrok-token-here":
    print("‚ùå ERROR: Please add your ngrok auth token!")
    print("\nüìù Steps:")
    print("   1. Go to: https://dashboard.ngrok.com/signup")
    print("   2. Sign up (free)")
    print("   3. Copy your authtoken")
    print("   4. Paste it above")
    print("   5. Run this cell again")
else:
    # Set the auth token
    ngrok.set_auth_token(NGROK_AUTH_TOKEN)
    print("‚úÖ Ngrok authenticated!")
    print("‚úÖ Ready to create public URL!")
    print("\nNow run Step 4 again! üöÄ")

# ============================================
# STEP 4: CREATE API SERVER & MAKE IT PUBLIC
# ============================================

print("üöÄ Setting up FastAPI server...")
print("="*50)

from fastapi import FastAPI, HTTPException, Request, Response
from fastapi.responses import HTMLResponse, JSONResponse # Import HTMLResponse and JSONResponse
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel, validator
import nest_asyncio
from pyngrok import ngrok
import uvicorn
import threading

# ============================================
# CREATE FASTAPI APP FOR FRONTEND
# ============================================

frontend_app = FastAPI(title="Civic Monitor Dashboard")

# Enable CORS
frontend_app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

print("‚úÖ Frontend app created")

# ============================================
# HTML FRONTEND CODE
# ============================================

HTML_TEMPLATE = """
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Civic Monitor AI Dashboard</title>
    <script src="https://cdn.jsdelivr.net/npm/echarts@5.4.3/dist/echarts.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        .header {
            background: white;
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            margin-bottom: 30px;
            text-align: center;
        }

        .header h1 {
            color: #667eea;
            font-size: 36px;
            margin-bottom: 10px;
        }

        .header p {
            color: #666;
            font-size: 16px;
        }

        .controls {
            background: white;
            padding: 25px;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            margin-bottom: 30px;
        }

        .controls h2 {
            color: #333;
            margin-bottom: 20px;
            font-size: 24px;
        }

        .query-section {
            margin-bottom: 20px;
        }

        .query-section label {
            display: block;
            color: #555;
            font-weight: 600;
            margin-bottom: 8px;
        }

        .query-section input {
            width: 100%;
            padding: 12px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 16px;
            transition: border 0.3s;
        }

        .query-section input:focus {
            outline: none;
            border-color: #667eea;
        }

        .button-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .btn {
            padding: 12px 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        .btn:active {
            transform: translateY(0);
        }

        .btn-generate {
            grid-column: 1 / -1;
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            font-size: 16px;
            padding: 15px;
        }

        .chart-container {
            background: white;
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            margin-bottom: 30px;
        }

        #chartDiv {
            width: 100%;
            height: 500px;
        }

        .loading {
            text-align: center;
            padding: 100px;
            color: #999;
            font-size: 18px;
        }

        .loading::after {
            content: '...';
            animation: dots 1.5s steps(4, end) infinite;
        }

        @keyframes dots {
            0%, 20% { content: '.'; }
            40% { content: '..'; }
            60%, 100% { content: '...'; }
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .stat-card {
            background: white;
            padding: 25px;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            border-left: 5px solid;
        }

        .stat-card h3 {
            color: #666;
            font-size: 14px;
            margin-bottom: 10px;
            text-transform: uppercase;
        }

        .stat-card .value {
            font-size: 36px;
            font-weight: bold;
            color: #333;
        }

        .stat-card.blue { border-left-color: #667eea; }
        .stat-card.green { border-left-color: #10b981; }
        .stat-card.orange { border-left-color: #f59e0b; }
        .stat-card.purple { border-left-color: #8b5cf6; }
    </style>
</head>
<body>
    <div class="container">
        <!-- Header -->
        <div class="header">
            <h1>üèôÔ∏è Civic Monitor AI Dashboard</h1>
            <p>AI-Powered Civic Issue Analytics for Vadodara</p>
        </div>

        <!-- Stats Cards -->
        <div class="stats-grid" id="statsGrid">
            <div class="stat-card blue">
                <h3>Total Issues</h3>
                <div class="value" id="totalIssues">-</div>
            </div>
            <div class="stat-card orange">
                <h3>Pending</h3>
                <div class="value" id="pendingIssues">-</div>
            </div>
            <div class="stat-card green">
                <h3>In Progress</h3>
                <div class="value" id="inProgressIssues">-</div>
            </div>
            <div class="stat-card purple">
                <h3>Resolved</h3>
                <div class="value" id="resolvedIssues">-</div>
            </div>
        </div>

        <!-- Controls -->
        <div class="controls">
            <h2>üìä Generate Visualizations</h2>

            <div class="query-section">
                <label for="userQuery">What would you like to visualize?</label>
                <input
                    type="text"
                    id="userQuery"
                    placeholder="E.g., Show ward-wise issue distribution"
                    value="Show ward-wise issue distribution as a bar chart"
                >
            </div>

            <div class="button-grid">
                <button class="btn" onclick="setQuery('Show ward-wise issue distribution')">
                    üìç Ward Distribution
                </button>
                <button class="btn" onclick="setQuery('Display status breakdown as pie chart')">
                    üìä Status Breakdown
                </button>
                <button class="btn" onclick="setQuery('Show severity levels')">
                    ‚ö†Ô∏è Severity Analysis
                </button>
                <button class="btn" onclick="setQuery('Show issue types breakdown')">
                    üîß Issue Types
                </button>
                <button class="btn" onclick="setQuery('Show daily trends over time')">
                    üìà Daily Trends
                </button>
                <button class="btn" onclick="setQuery('Show engineer workload')">
                    üë∑ Engineer Workload
                </button>

                <button class="btn btn-generate" onclick="generateChart()">
                    ‚ú® Generate Chart with AI
                </button>
            </div>
        </div>

        <!-- Chart Display -->
        <div class="chart-container">
            <div id="chartDiv">
                <div class="loading">Select a visualization type to begin</div>
            </div>
        </div>
    </div>

    <script>
        const API_URL = window.location.origin;
        let chart = null;

        // Initialize ECharts
        function initChart() {
            const chartDiv = document.getElementById('chartDiv');
            chart = echarts.init(chartDiv);
        }

        // Load stats
        async function loadStats() {
            try {
                const response = await fetch(`${API_URL}/api/stats`);
                const data = await response.json();

                document.getElementById('totalIssues').textContent = data.total_issues;
                document.getElementById('pendingIssues').textContent = data.pending;
                document.getElementById('inProgressIssues').textContent = data.in_progress;
                document.getElementById('resolvedIssues').textContent = data.resolved;
            } catch (error) {
                console.error('Error loading stats:', error);
            }
        }

        // Set query in input
        function setQuery(query) {
            document.getElementById('userQuery').value = query;
        }

        // Generate chart
        async function generateChart() {
            const query = document.getElementById('userQuery').value;

            if (!query.trim()) {
                alert('Please enter a query!');
                return;
            }

            // Show loading
            document.getElementById('chartDiv').innerHTML =
                '<div class="loading">AI is generating your chart</div>';

            try {
                // Call API to generate chart
                const response = await fetch(`${API_URL}/api/generate-chart`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ query: query })
                });

                const result = await response.json();

                if (result.success) {
                    // Reinitialize chart
                    initChart();

                    // Set option
                    chart.setOption(result.echarts_config);

                    // Make chart responsive
                    window.addEventListener('resize', () => {
                        chart.resize();
                    });
                } else {
                    document.getElementById('chartDiv').innerHTML =
                        `<div class="loading">Error: ${result.error}</div>`;
                }

            } catch (error) {
                console.error('Error:', error);
                document.getElementById('chartDiv').innerHTML =
                    '<div class="loading">Error generating chart. Please try again.</div>';
            }
        }

        // Initialize on load
        window.onload = () => {
            loadStats();
        };
    </script>
</body>
</html>
"""

# ============================================
# API ENDPOINTS
# ============================================

@frontend_app.get("/", response_class=HTMLResponse)
async def home():
    """Serve the HTML frontend"""
    return HTML_TEMPLATE

@frontend_app.get("/api/stats")
async def get_stats():
    """Get summary statistics"""
    try:
        # Get status distribution from MCP
        status_data = mcp_server._get_status_distribution()

        stats = {
            "total_issues": sum(item['count'] for item in status_data['data']),
            "pending": next((item['count'] for item in status_data['data'] if item['status'] == 'pending'), 0),
            "in_progress": next((item['count'] for item in status_data['data'] if item['status'] == 'in_progress'), 0),
            "resolved": next((item['count'] for item in status_data['data'] if item['status'] == 'resolved'), 0),
        }

        return stats
    except Exception as e:
        return {"error": str(e)}

@frontend_app.post("/api/generate-chart")
async def generate_chart_api(request: Request):
    """Generate chart using React Agent"""
    try:
        body = await request.json()
        query = body.get('query', '')

        # Helper to infer aggregation type from query
        def _infer_aggregation_type(user_query: str) -> str:
            user_query_lower = user_query.lower()
            if "ward-wise" in user_query_lower or "ward distribution" in user_query_lower:
                return "ward_wise_counts"
            elif "status breakdown" in user_query_lower or "status" in user_query_lower:
                return "status_distribution"
            elif "severity levels" in user_query_lower or "severity analysis" in user_query_lower:
                return "severity_breakdown"
            elif "issue types" in user_query_lower:
                return "issue_type_counts"
            elif "daily trends" in user_query_lower or "time" in user_query_lower:
                return "daily_trends"
            # Default to ward-wise counts if no specific type is inferred
            return "ward_wise_counts" # Fallback

        # 1. Infer aggregation type from the query
        aggregation_type = _infer_aggregation_type(query)

        # 2. Get the aggregated data using the inferred type
        aggregated_data = mcp_server.get_aggregated_data(aggregation_type)

        # 3. Use AI to generate chart config with both query and aggregated data
        echarts_config = react_agent.generate_chart_config(user_query=query, aggregated_data=aggregated_data)

        return JSONResponse({
            "success": True,
            "echarts_config": echarts_config
        })

    except Exception as e:
        return JSONResponse({
            "success": False,
            "error": str(e)
        })

print("‚úÖ API endpoints created")

# ============================================
# DATA & AGGREGATOR INITIALIZATION (for FastAPI)
# ============================================

# These will store our data and AI generator instances for the API
mcp_server = None # Re-use the SecureDataAggregator instance
react_agent = None # Re-use the AIChartGenerator instance

print("üìä Initializing data and AI agent for API...")

# Check if dependencies are defined, otherwise instruct user
if 'SecureDataAggregator' not in globals() or 'sample_data' not in globals():
    print("‚ùå ERROR: 'SecureDataAggregator' or 'sample_data' are not defined.")
    print("   Please run 'STEP 2: IMPORT & CREATE SAMPLE DATA' (cell qfobJh2Ow273) first.")
    raise NameError("Dependencies missing: SecureDataAggregator, sample_data")

if 'chart_generator' not in globals():
    print("‚ùå ERROR: 'chart_generator' is not defined.")
    print("   Please run 'STEP 3: AI CHART GENERATOR (OpenAI Version)' (cell 5Sdd4fAn0OzS) first.")
    raise NameError("Dependencies missing: chart_generator")

# Initialize data and aggregator using the globally available sample_data
mcp_server = SecureDataAggregator(sample_data)

# Initialize AI chart generator using the globally available chart_generator
react_agent = chart_generator # Assign the existing instance

print(f"‚úÖ Loaded {len(sample_data)} issues into API aggregator")
print("‚úÖ AI Chart Generator linked for API")

# ============================================
# START SERVER WITH NGROK
# ============================================

print("\nüåê Starting server with ngrok...")
print("="*50)

# Allow nested event loops (required for Colab)
nest_asyncio.apply()

# Start ngrok tunnel to make server public
# Check if an ngrok tunnel is already running to avoid errors
try:
    # Disconnect any existing tunnels before starting a new one
    ngrok.kill()
except Exception as e:
    print(f"Warning: Could not kill existing ngrok tunnels. It might be already stopped or an error occurred: {e}")

public_url = ngrok.connect(8000)
print(f"\n‚úÖ SERVER IS LIVE!")
print("="*50)
print(f"\nüåê Your Public URL: {public_url}")
print(f"üìö API Documentation: {public_url}/docs")
print(f"üè† Dashboard Frontend: {public_url}/")
print("\n" + "="*50)

print("\nüìã SHARE THESE WITH YOUR TEAM:")
print(f"\n   For Ritika (React App):")
print(f"   API_BASE_URL = '{public_url}'")
print("\n   Test the dashboard by opening the link above!")

print("\n" + "="*50)
print("‚ö†Ô∏è  IMPORTANT: Keep this cell running!")
print("   Don't stop it or the server will stop")
print("="*50)

# Start the server in a separate thread
def run_server():
    uvicorn.run(frontend_app, host="0.0.0.0", port=8000, log_level="info")

# Run server in background thread
server_thread = threading.Thread(target=run_server, daemon=True)
server_thread.start()

print("\n‚úÖ Server started in background!")

print("\n" + "="*50)
print("‚úÖ STEP 4 COMPLETE!")
print("‚úÖ YOUR API IS NOW LIVE AND PUBLIC!")
print("="*50)

# Keep the cell running indefinitely while the server runs in the background
import time
print("\n‚è≥ Server running... (Press Stop button to stop)")
try:
    while True:
        time.sleep(1)
except KeyboardInterrupt:
    print("\nüõë Server stopped by user.")